package cmd

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"runtime"

	"github.com/VKCOM/noverify/src/cmd"
	"github.com/VKCOM/noverify/src/linter"

	"github.com/vkcom/nocolor/internal/checkers"
	"github.com/vkcom/nocolor/internal/walkers"
)

// Build* are initialized during the build via -ldflags
var (
	Version      string
	BuildTime    string
	BuildOSUname string
	BuildCommit  string
)

func printVersion(mainConfig *cmd.MainConfig) {
	fmt.Print("NoColor, ")
	if BuildCommit == "" {
		fmt.Printf("version %s: built without version info", mainConfig.LinterVersion)
	} else {
		fmt.Printf("version %s: built on: %s OS: %s Commit: %s\n", mainConfig.LinterVersion, BuildTime, BuildOSUname, BuildCommit)
	}
}

// LinterReports is a global map that stores all custom
// reports generated by NoVerify inside walkers.
var LinterReports []*linter.Report

func registerReportWatcher(r *linter.Report) bool {
	if checkers.Contains(r.CheckName) {
		LinterReports = append(LinterReports, r)
	}

	return false
}

// DefaultCacheDir function returns the default, depending on the system, directory for storing the cache.
func DefaultCacheDir() string {
	defaultCacheDir, err := os.UserCacheDir()
	if err != nil {
		return ""
	}
	return filepath.Join(defaultCacheDir, "nocolor-cache")
}

// Main is the function that launches the program.
func Main() {
	config := linter.NewConfig("8.1")
	context := walkers.NewGlobalContext(nil)

	status, err := cmd.Run(&cmd.MainConfig{
		BeforeReport:             registerReportWatcher,
		LinterVersion:            Version,
		RegisterCheckers:         checkers.List,
		LinterConfig:             config,
		DisableCriticalIssuesLog: true,
		AfterFlagParse: func(env cmd.InitEnvironment) {
			context.Info = env.MetaInfo
		},
		ModifyApp: func(app *cmd.App) {
			app.Name = "nocolor"
			app.Description = "Architecture checking tool based on the concept of colors"

			// Clear all the default commands.
			app.Commands = nil

			app.Commands = append(app.Commands, &cmd.Command{
				Name:        "version",
				Description: "The command to output the tool version",
				Action: func(ctx *cmd.AppContext) (int, error) {
					printVersion(ctx.MainConfig)
					return 0, nil
				},
			})

			app.Commands = append(app.Commands, &cmd.Command{
				Name:        "cache-clear",
				Description: "The command to clear the cache",
				Action: func(ctx *cmd.AppContext) (int, error) {
					return CacheClear()
				},
			})

			app.Commands = append(app.Commands, &cmd.Command{
				Name:        "init",
				Description: "The command to create a template palette in the project folder",
				Action: func(ctx *cmd.AppContext) (int, error) {
					return Init()
				},
			})

			app.Commands = append(app.Commands, &cmd.Command{
				Name:        "check",
				Description: "The command to start checking files",
				Arguments: []*cmd.Argument{
					{
						Name:        "targets",
						Description: "Folders or files for analysis",
					},
				},
				RegisterFlags: func(ctx *cmd.AppContext) (*flag.FlagSet, *cmd.FlagsGroups) {
					flags := &extraCheckFlags{}

					fs := flag.NewFlagSet("check", flag.ContinueOnError)
					groups := cmd.NewFlagsGroups()

					groups.AddGroup("Color")
					groups.AddGroup("Language")
					groups.AddGroup("Files")
					groups.AddGroup("Additional")

					// We don't need all the flags from NoVerify, so we only register some of them.
					fs.IntVar(&ctx.ParsedFlags.MaxFileSize, "max-sum-filesize", 10*1024*1024, "Max total file size to be parsed concurrently in bytes (limits max memory consumption)")
					fs.IntVar(&ctx.ParsedFlags.MaxConcurrency, "cores", runtime.NumCPU(), "Max number of cores to use")
					fs.StringVar(&ctx.ParsedFlags.StubsDir, "stubs-dir", "", "Directory with custom phpstorm-stubs")
					fs.StringVar(&ctx.ParsedFlags.CacheDir, "cache-dir", DefaultCacheDir(), "Directory for linter cache (greatly improves indexing speed)")
					fs.BoolVar(&ctx.ParsedFlags.DisableCache, "disable-cache", false, "If set, cache is not used and cache-dir is ignored")

					groups.Add("Additional", "cores")
					groups.Add("Additional", "cache-dir")
					groups.Add("Additional", "disable-cache")
					groups.Add("Additional", "max-sum-filesize")
					groups.Add("Additional", "stubs-dir")

					fs.StringVar(&ctx.ParsedFlags.IndexOnlyFiles, "index-only-files", "", "Comma-separated list of paths to files, which should be indexed, but not analyzed")
					fs.StringVar(&ctx.ParsedFlags.PhpExtensionsArg, "php-exts", "php,inc,php5,phtml", "List of PHP file extensions to be analyzed")
					fs.StringVar(&flags.Output, "output", "", "Path to the file where the errors will be written in JSON format")

					groups.Add("Files", "index-only-files")
					groups.Add("Files", "php-exts")
					groups.Add("Files", "output")

					fs.BoolVar(&ctx.ParsedFlags.PHP7, "php7", false, "Analyze as PHP 7")
					groups.Add("Language", "php7")

					// Some values need to be set manually.
					ctx.ParsedFlags.AllowAll = true
					ctx.ParsedFlags.ReportsCritical = cmd.AllNonNoticeChecks

					fs.StringVar(&flags.PaletteSrc, "palette", "palette.yaml", "File with color palette")
					fs.StringVar(&flags.ColorTag, "tag", "color", "The tag to be used to set the color in PHPDoc")

					groups.Add("Color", "palette")
					groups.Add("Color", "tag")

					ctx.CustomFlags = flags
					return fs, groups
				},
				Action: func(ctx *cmd.AppContext) (int, error) {
					return Check(ctx, context)
				},
			})
		},
	})
	if err != nil {
		log.Println(err)
	}

	os.Exit(status)
}
