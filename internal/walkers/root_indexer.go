package walkers

import (
	"github.com/VKCOM/noverify/src/ir"
	"github.com/VKCOM/noverify/src/linter"
	"github.com/VKCOM/noverify/src/meta"
	"github.com/vkcom/nocolor/internal/palette"
	"github.com/vkcom/nocolor/internal/symbols"
	"github.com/vkcom/nocolor/internal/walkers/namegen"
)

// RootIndexer is a walker that collects information about function
// definitions, as well as about the files where they are defined.
type RootIndexer struct {
	linter.RootCheckerDefaults

	ctx       *linter.RootContext
	meta      FileMeta
	state     *meta.ClassParseState
	palette   *palette.Palette
	globalCtx *GlobalContext

	colorTag string
}

// NewRootIndexer creates a new walker.
func NewRootIndexer(pal *palette.Palette, globalCtx *GlobalContext, ctx *linter.RootContext, colorTag string) *RootIndexer {
	return &RootIndexer{
		ctx:       ctx,
		globalCtx: globalCtx,
		meta:      NewFileMeta(),
		palette:   pal,
		colorTag:  colorTag,
		state:     ctx.ClassParseState(),
	}
}

// BeforeEnterFile processes all files, creating a new function
// for each with an autogenerated name.
func (r *RootIndexer) BeforeEnterFile() {
	external := namegen.FromStubs(r.ctx.Filename())
	if external {
		return
	}

	r.meta.Functions.Add(&symbols.Function{
		Name:     namegen.FileFunction(r.ctx.Filename()),
		Type:     symbols.MainFunc,
		Colors:   &palette.ColorContainer{},
		Called:   symbols.NewFunctions(),
		CalledBy: symbols.NewFunctions(),
	})
}

// AfterLeaveFile updates the cache.
func (r *RootIndexer) AfterLeaveFile() {
	r.globalCtx.UpdateMeta(&r.meta, "")
}

// BeforeLeaveNode collects information about functions and methods.
func (r *RootIndexer) BeforeLeaveNode(n ir.Node) {
	switch n := n.(type) {
	case *ir.ClassStmt:
		className := namegen.ClassFQN(r.state, n.ClassName.Value)

		class, ok := r.meta.Classes.Get(className)
		if !ok {
			return
		}

		// If the class does not have an explicit constructor, then we
		// need to create a pseudo version of it so that later we can
		// link a constructor with function that calls the new operator.
		if !class.WithExplicitConstructor {
			r.meta.Functions.Add(&symbols.Function{
				Name:     namegen.DefaultConstructor(className),
				Type:     symbols.LocalFunc,
				Pos:      meta.ElementPosition{},
				Colors:   class.Colors,
				Called:   symbols.NewFunctions(),
				CalledBy: symbols.NewFunctions(),
			})
		}
	default:
	}
}

// BeforeEnterNode collects information about functions and methods.
func (r *RootIndexer) BeforeEnterNode(n ir.Node) {
	external := namegen.FromStubs(r.ctx.Filename())
	if external {
		return
	}

	switch n := n.(type) {
	case *ir.ClassStmt:
		name := namegen.ClassFQN(r.state, n.ClassName.Value)

		r.meta.Classes.Add(&symbols.Class{
			Name:   name,
			Type:   symbols.PlainClass,
			Pos:    r.getElementPos(n),
			Colors: &palette.ColorContainer{},
		})

	case *ir.InterfaceStmt:
		name := namegen.ClassFQN(r.state, n.InterfaceName.Value)

		r.meta.Classes.Add(&symbols.Class{
			Name:   name,
			Type:   symbols.Interface,
			Pos:    r.getElementPos(n),
			Colors: &palette.ColorContainer{},
		})

	case *ir.TraitStmt:
		name := namegen.ClassFQN(r.state, n.TraitName.Value)

		r.meta.Classes.Add(&symbols.Class{
			Name:   name,
			Type:   symbols.Trait,
			Pos:    r.getElementPos(n),
			Colors: &palette.ColorContainer{},
		})

	case *ir.ClassMethodStmt:
		className := r.state.CurrentClass
		methodName := namegen.Method(className, n.MethodName.Value)

		typ := symbols.LocalFunc
		if external {
			typ = symbols.ExternFunc
		}

		r.meta.Functions.Add(&symbols.Function{
			Name:     methodName,
			Type:     typ,
			Pos:      r.getElementPos(n),
			Colors:   &palette.ColorContainer{},
			Called:   symbols.NewFunctions(),
			CalledBy: symbols.NewFunctions(),
		})

	case *ir.FunctionStmt:
		name := namegen.FunctionFQN(r.state, n.FunctionName.Value)

		typ := symbols.LocalFunc
		if external {
			typ = symbols.ExternFunc
		}

		r.meta.Functions.Add(&symbols.Function{
			Name:     name,
			Type:     typ,
			Pos:      r.getElementPos(n),
			Colors:   &palette.ColorContainer{},
			Called:   symbols.NewFunctions(),
			CalledBy: symbols.NewFunctions(),
		})
	}
}

func (r *RootIndexer) getElementPos(n ir.Node) meta.ElementPosition {
	pos := ir.GetPosition(n)

	return meta.ElementPosition{
		Filename:  r.ctx.ClassParseState().CurrentFile,
		Character: int32(0),
		Line:      int32(pos.StartLine),
		EndLine:   int32(pos.EndLine),
		Length:    int32(pos.EndPos - pos.StartPos),
	}
}
